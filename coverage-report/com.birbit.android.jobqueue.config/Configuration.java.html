<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Configuration.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jobqueue</a> &gt; <a href="index.source.html" class="el_package">com.birbit.android.jobqueue.config</a> &gt; <span class="el_source">Configuration.java</span></div><h1>Configuration.java</h1><pre class="source lang-java linenums">package com.birbit.android.jobqueue.config;

import android.content.Context;
import android.net.ConnectivityManager;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;

import com.birbit.android.jobqueue.DefaultQueueFactory;
import com.birbit.android.jobqueue.JobQueue;
import com.birbit.android.jobqueue.QueueFactory;
import com.birbit.android.jobqueue.di.DependencyInjector;
import com.birbit.android.jobqueue.log.CustomLogger;
import com.birbit.android.jobqueue.log.JqLog;
import com.birbit.android.jobqueue.network.NetworkUtil;
import com.birbit.android.jobqueue.network.NetworkUtilImpl;
import com.birbit.android.jobqueue.persistentQueue.sqlite.SqliteJobQueue;
import com.birbit.android.jobqueue.scheduling.Scheduler;
import com.birbit.android.jobqueue.timer.SystemTimer;
import com.birbit.android.jobqueue.timer.Timer;

import java.util.concurrent.ThreadFactory;

/**
 * {@link com.birbit.android.jobqueue.JobManager} configuration object
 */
@SuppressWarnings(&quot;WeakerAccess&quot;)
public class Configuration {
    /**
     * The default id for a Job. If you have multiple JobManagers, you should set this value via
     * {@link Builder#id(String)}
     */
    public static final String DEFAULT_ID = &quot;default_job_manager&quot;;
    /**
     * The default timeout for an idle thread before it is destroyed
     */
    public static final int DEFAULT_THREAD_KEEP_ALIVE_SECONDS = 15;
    /**
     * The default number of jobs per thread before JobManager creates a new one
     */
    public static final int DEFAULT_LOAD_FACTOR_PER_CONSUMER = 3;
    /**
     * The default max number of consumers that will be created by the JobManager
     */
    public static final int MAX_CONSUMER_COUNT = 5;
    /**
     * The default min number of consumers that will be kept alive by the JobManager
     */
    public static final int MIN_CONSUMER_COUNT = 0;
    /**
     * The default priority for new job consumers ({@code Thread.NORM_PRIORITY}).
     */
    public static final int DEFAULT_THREAD_PRIORITY = Thread.NORM_PRIORITY;

<span class="fc" id="L54">    String id = DEFAULT_ID;</span>
<span class="fc" id="L55">    int maxConsumerCount = MAX_CONSUMER_COUNT;</span>
<span class="fc" id="L56">    int minConsumerCount = MIN_CONSUMER_COUNT;</span>
<span class="fc" id="L57">    int consumerKeepAlive = DEFAULT_THREAD_KEEP_ALIVE_SECONDS;</span>
<span class="fc" id="L58">    int loadFactor = DEFAULT_LOAD_FACTOR_PER_CONSUMER;</span>
    Context appContext;
    QueueFactory queueFactory;
    DependencyInjector dependencyInjector;
    NetworkUtil networkUtil;
<span class="fc" id="L63">    CustomLogger customLogger = new JqLog.ErrorLogger();</span>
    Timer timer;
    Scheduler scheduler;
<span class="fc" id="L66">    boolean inTestMode = false;</span>
<span class="fc" id="L67">    boolean resetDelaysOnRestart = false;</span>
<span class="fc" id="L68">    int threadPriority = DEFAULT_THREAD_PRIORITY;</span>
<span class="fc" id="L69">    boolean batchSchedulerRequests = true;</span>
<span class="fc" id="L70">    ThreadFactory threadFactory = null;</span>

<span class="fc" id="L72">    private Configuration(){</span>
        //use builder instead
<span class="fc" id="L74">    }</span>

    @NonNull
    public Context getAppContext() {
<span class="fc" id="L78">        return appContext;</span>
    }

    @NonNull
    public String getId() {
<span class="fc" id="L83">        return id;</span>
    }

    public boolean batchSchedulerRequests() {
<span class="fc" id="L87">        return batchSchedulerRequests;</span>
    }

    @NonNull
    public QueueFactory getQueueFactory() {
<span class="fc" id="L92">        return queueFactory;</span>
    }

    @Nullable
    public DependencyInjector getDependencyInjector() {
<span class="fc" id="L97">        return dependencyInjector;</span>
    }

    public int getConsumerKeepAlive() {
<span class="fc" id="L101">        return consumerKeepAlive;</span>
    }

    @NonNull
    public NetworkUtil getNetworkUtil() {
<span class="fc" id="L106">        return networkUtil;</span>
    }

    public int getMaxConsumerCount() {
<span class="fc" id="L110">        return maxConsumerCount;</span>
    }

    public int getMinConsumerCount() {
<span class="fc" id="L114">        return minConsumerCount;</span>
    }

    @Nullable
    public CustomLogger getCustomLogger() {
<span class="fc" id="L119">        return customLogger;</span>
    }

    public int getLoadFactor() {
<span class="fc" id="L123">        return loadFactor;</span>
    }

    public boolean isInTestMode() {
<span class="fc" id="L127">        return inTestMode;</span>
    }

    @NonNull
    public Timer getTimer() {
<span class="fc" id="L132">        return timer;</span>
    }

    public boolean resetDelaysOnRestart() {
<span class="fc" id="L136">        return resetDelaysOnRestart;</span>
    }

    @Nullable
    public Scheduler getScheduler() {
<span class="fc" id="L141">        return scheduler;</span>
    }

    public int getThreadPriority() {
<span class="fc" id="L145">        return threadPriority;</span>
    }

    @Nullable
    public ThreadFactory getThreadFactory() {
<span class="fc" id="L150">        return threadFactory;</span>
    }

    @SuppressWarnings(&quot;unused&quot;)
    public static final class Builder {
        private Configuration configuration;

<span class="fc" id="L157">        public Builder(@NonNull Context context) {</span>
<span class="fc" id="L158">            this.configuration = new Configuration();</span>
<span class="fc" id="L159">            this.configuration.appContext = context.getApplicationContext();</span>
<span class="fc" id="L160">        }</span>

        /**
         * provide and ID for this job manager to be used while creating persistent queue. it is useful if you are going to
         * create multiple instances of it.
         * default id is {@link #DEFAULT_ID}
         * @param id if you have multiple instances of job manager, you should provide an id to distinguish their persistent files.
         * @return This Configuration for easy chaining
         */
        @NonNull
        public Builder id(@NonNull String id) {
<span class="fc" id="L171">            configuration.id = id;</span>
<span class="fc" id="L172">            return this;</span>
        }

        /**
         * When JobManager runs out of `ready` jobs, it will keep consumers alive for this duration.
         * It defaults to {@link #DEFAULT_THREAD_KEEP_ALIVE_SECONDS}
         * @param keepAlive in seconds
         * @return This Configuration for easy chaining
         */
        @NonNull
        public Builder consumerKeepAlive(int keepAlive) {
<span class="fc" id="L183">            configuration.consumerKeepAlive = keepAlive;</span>
<span class="fc" id="L184">            return this;</span>
        }

        /**
         * JobManager 1.x versions used to clear delay for existing jobs when the application is
         * restarted because there is no reliable way to measure time difference between device
         * reboots (and from the app's perspective, device reboot is no different than app restart).
         * &lt;p&gt;
         * This may cause unexpected behaviors as delayed persistent jobs instantly become available
         * when application restarts.
         * &lt;p&gt;
         * JobManager 2.x versions change this behavior and does not reset the delay of persistent
         * jobs on restart. This may create a problem if jobs were added when the device's clock is
         * set to some unreasonable time but for common cases, it is more desirable.
         * &lt;p&gt;
         * You can get the v1 behavior by calling this method. Note that it will also effect jobs
         * which require network with a timeout. Their timeouts will be triggered on restart if you
         * call this method.
         *
         * @return This Configuration for easy chaining
         */
        @NonNull
        public Builder resetDelaysOnRestart() {
<span class="nc" id="L207">            configuration.resetDelaysOnRestart = true;</span>
<span class="nc" id="L208">            return this;</span>
        }

        /**
         * JobManager needs one persistent and one non-persistent {@link JobQueue} to function.
         * By default, it will use {@link SqliteJobQueue} and
         * {@link com.birbit.android.jobqueue.inMemoryQueue.SimpleInMemoryPriorityQueue}
         * You can provide your own implementation if they don't fit your needs. Make sure it passes all tests in
         * {@code JobQueueTestBase} to ensure it will work fine.
         * @param queueFactory your custom queue factory.
         *
         * @return This Configuration for easy chaining
         */
        @NonNull
        public Builder queueFactory(@Nullable QueueFactory queueFactory) {
<span class="nc bnc" id="L223" title="All 4 branches missed.">            if(configuration.queueFactory != null &amp;&amp; queueFactory != null) {</span>
<span class="nc" id="L224">                throw new RuntimeException(&quot;already set a queue factory. This might happen if&quot;</span>
                        + &quot;you've provided a custom job serializer&quot;);
            }
<span class="nc" id="L227">            configuration.queueFactory = queueFactory;</span>
<span class="nc" id="L228">            return this;</span>
        }

        /**
         * convenient configuration to replace job serializer while using {@link SqliteJobQueue}
         * queue for persistence. By default, it uses a
         * {@link com.birbit.android.jobqueue.persistentQueue.sqlite.SqliteJobQueue.JavaSerializer}
         * which will use default Java serialization.
         * @param jobSerializer The serializer to be used to persist jobs.
         *
         * @return This Configuration for easy chaining
         */
        @NonNull
        public Builder jobSerializer(@NonNull SqliteJobQueue.JobSerializer jobSerializer) {
<span class="fc" id="L242">            configuration.queueFactory = new DefaultQueueFactory(jobSerializer);</span>
<span class="fc" id="L243">            return this;</span>
        }

        /**
         * By default, Job Manager comes with a simple {@link NetworkUtilImpl} that queries {@link ConnectivityManager}
         * to check if network connection exists. You can provide your own if you need a custom logic (e.g. check your
         * server health etc).
         *
         * @param networkUtil The NetworkUtil to be used by the JobManager. If it is null, JobManager
         *                    will use {@link NetworkUtilImpl}
         * @return This Configuration for easy chaining
         */
        @NonNull
        public Builder networkUtil(@Nullable NetworkUtil networkUtil) {
<span class="fc" id="L257">            configuration.networkUtil = networkUtil;</span>
<span class="fc" id="L258">            return this;</span>
        }

        /**
         * JobManager is suitable for DependencyInjection. Just provide your DependencyInjector and it will call it
         * before {Job#onAdded} method is called.
         * if job is persistent, it will also be called before run method.
         * 
         * @param injector your dependency injector interface, if using one
         *
         * @return This Configuration for easy chaining
         */
        @NonNull
        public Builder injector(@Nullable DependencyInjector injector) {
<span class="fc" id="L272">            configuration.dependencyInjector = injector;</span>
<span class="fc" id="L273">            return this;</span>
        }

        /**
         * # of max consumers to run concurrently. defaults to {@link #MAX_CONSUMER_COUNT}
         * @param count The max number of threads that JobManager can create to run jobs
         *
         * @return This Configuration for easy chaining
         */
        @NonNull
        public Builder maxConsumerCount(int count) {
<span class="fc" id="L284">            configuration.maxConsumerCount = count;</span>
<span class="fc" id="L285">            return this;</span>
        }

        /**
         * you can specify to keep minConsumers alive even if there are no ready jobs. defaults to
         * {@link #MIN_CONSUMER_COUNT}
         *
         * @param count The min of of threads that JobManager will keep alive even if they are idle.
         *
         * @return This Configuration for easy chaining
         */
        @NonNull
        public Builder minConsumerCount(int count) {
<span class="fc" id="L298">            configuration.minConsumerCount = count;</span>
<span class="fc" id="L299">            return this;</span>
        }

        /**
         * You can specify a custom timer to control task execution. Useful for testing.
         *
         * @param timer The timer to use
         *
         * @return This Configuration for easy chaining
         */
        @NonNull
        public Builder timer(@Nullable Timer timer) {
<span class="fc" id="L311">            configuration.timer = timer;</span>
<span class="fc" id="L312">            return this;</span>
        }

        /**
         * you can provide a custom logger to get logs from JobManager.
         * by default, JobManager only logs error via Android's &lt;code&gt;Log.e&lt;/code&gt;.
         *
         * @param logger The logger to be used by the JobManager.
         *
         * @return This Configuration for easy chaining
         */
        @NonNull
        public Builder customLogger(@Nullable CustomLogger logger) {
<span class="nc" id="L325">            configuration.customLogger = logger;</span>
<span class="nc" id="L326">            return this;</span>
        }

        /**
         * calculated by # of jobs (running+waiting) per thread
         * for instance, at a given time, if you have two consumers and 10 jobs in waiting queue (or running right now), load is
         * (10/2) =5
         * defaults to {@link #DEFAULT_LOAD_FACTOR_PER_CONSUMER}
         *
         * @param loadFactor Number of available jobs per thread
         *
         * @return This Configuration for easy chaining
         */
        @NonNull
        public Builder loadFactor(int loadFactor) {
<span class="fc" id="L341">            configuration.loadFactor = loadFactor;</span>
<span class="fc" id="L342">            return this;</span>
        }

        /**
         * Sets the JobManager in test mode. This information is passed to JobQueue's.
         * If you are using default JobQueues, calling this method will cause {@link SqliteJobQueue}
         * to use an in-memory database.
         *
         * @return This Configuration for easy chaining
         */
        @NonNull
        public Builder inTestMode() {
<span class="fc" id="L354">            configuration.inTestMode = true;</span>
<span class="fc" id="L355">            return this;</span>
        }

        /**
         * Assigns a scheduler that can be used to wake up the application when JobManager has jobs
         * to execute. This is the integration point with the system
         * {@link android.app.job.JobScheduler}.
         * &lt;p&gt;
         * &lt;b&gt;Batching&lt;/b&gt;
         * &lt;p&gt;
         * By default, JobManager batches scheduling requests so that it will not call JobScheduler
         * too many times. For instance, if a persistent job that requires network is added, when
         * batching is enabled, JobManager creates the JobScheduler request with
         * {@link com.birbit.android.jobqueue.BatchingScheduler#DEFAULT_BATCHING_PERIOD_IN_MS} delay.
         * Any subsequent job request that has the same criteria will use the previous batching
         * request. This way, JobManager can avoid making a JobScheduler request for every job.
         * It will still execute the Job if it becomes available without waiting for the delay but
         * if the application is killed, the JobScheduler will wait until the delay passes before
         * waking up the application to consume the jobs.
         *
         * @param scheduler The scheduler to be used
         * @param batch     Defines whether the scheduling requests should be batched or not.
         *
         * @return This Configuration for easy chaining
         */
        @NonNull
        public Builder scheduler(@Nullable Scheduler scheduler, boolean batch) {
<span class="fc" id="L382">            configuration.scheduler = scheduler;</span>
<span class="fc" id="L383">            configuration.batchSchedulerRequests = batch;</span>
<span class="fc" id="L384">            return this;</span>
        }

        /**
         * Sets the priority for the threads of this manager. By default it is
         * {@link #DEFAULT_THREAD_PRIORITY}.
         * &lt;p&gt;
         * If a {@link ThreadFactory} is provided, this value is ignored.
         *
         * @param threadPriority The thread priority to be used for new jobs
         *
         * @return This Configuration for easy chaining
         */
        @NonNull
        public Builder consumerThreadPriority(int threadPriority) {
<span class="nc" id="L399">            configuration.threadPriority = threadPriority;</span>
<span class="nc" id="L400">            return this;</span>
        }

        /**
         * Assigns a scheduler that can be used to wake up the application when JobManager has jobs
         * to execute. This is the integration point with the system
         * {@link android.app.job.JobScheduler}.
         * &lt;p&gt;
         * &lt;b&gt;Batching&lt;/b&gt;
         * &lt;p&gt;
         * By default, JobManager batches scheduling requests so that it will not call JobScheduler
         * too many times. For instance, if a persistent job that requires network is added, when
         * batching is enabled, JobManager creates the JobScheduler request with
         * {@link com.birbit.android.jobqueue.BatchingScheduler#DEFAULT_BATCHING_PERIOD_IN_MS} delay.
         * Any subsequent job request that has the same criteria will use the previous batching
         * request. This way, JobManager can avoid making a JobScheduler request for every job.
         * It will still execute the Job if it becomes available without waiting for the delay but
         * if the application is killed, the JobScheduler will wait until the delay passes before
         * waking up the application to consume the jobs.
         *
         * @param scheduler The scheduler to be used
         *
         * @return This Configuration.Builder for easy chaining
         */
        @NonNull
        public Builder scheduler(@Nullable Scheduler scheduler) {
<span class="nc" id="L426">            return scheduler(scheduler, true);</span>
        }

        /**
         * Provide a factory class to create new worker instances when JobManager needs them.
         * &lt;p&gt;
         * When a factory is installed, it becomes its responsibility to configure
         * the {@link Thread} with proper group and priority. JobManager will use the {@link Thread}
         * as is.
         *
         * @param threadFactory The factory to be used
         *
         * @return This Configuration.Builder for easy chaining
         */
        @NonNull
        public Builder threadFactory(@Nullable final ThreadFactory threadFactory) {
<span class="fc" id="L442">            configuration.threadFactory = threadFactory;</span>
<span class="fc" id="L443">            return this;</span>
        }

        @NonNull
        public Configuration build() {
<span class="fc bfc" id="L448" title="All 2 branches covered.">            if(configuration.queueFactory == null) {</span>
<span class="fc" id="L449">                configuration.queueFactory = new DefaultQueueFactory();</span>
            }
<span class="fc bfc" id="L451" title="All 2 branches covered.">            if(configuration.networkUtil == null) {</span>
<span class="fc" id="L452">                configuration.networkUtil = new NetworkUtilImpl(configuration.appContext);</span>
            }
<span class="fc bfc" id="L454" title="All 2 branches covered.">            if (configuration.timer == null) {</span>
<span class="fc" id="L455">                configuration.timer = new SystemTimer();</span>
            }
<span class="fc" id="L457">            return configuration;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.1.201405082137</span></div></body></html>