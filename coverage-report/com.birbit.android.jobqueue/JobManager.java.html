<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>JobManager.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jobqueue</a> &gt; <a href="index.source.html" class="el_package">com.birbit.android.jobqueue</a> &gt; <span class="el_source">JobManager.java</span></div><h1>JobManager.java</h1><pre class="source lang-java linenums">package com.birbit.android.jobqueue;

import android.os.Looper;
import android.support.annotation.NonNull;
import android.support.annotation.Nullable;
import android.support.annotation.VisibleForTesting;

import com.birbit.android.jobqueue.callback.JobManagerCallback;
import com.birbit.android.jobqueue.callback.JobManagerCallbackAdapter;
import com.birbit.android.jobqueue.config.Configuration;
import com.birbit.android.jobqueue.log.JqLog;
import com.birbit.android.jobqueue.messaging.Message;
import com.birbit.android.jobqueue.messaging.MessageFactory;
import com.birbit.android.jobqueue.messaging.MessageQueue;
import com.birbit.android.jobqueue.messaging.PriorityMessageQueue;
import com.birbit.android.jobqueue.messaging.message.AddJobMessage;
import com.birbit.android.jobqueue.messaging.message.CancelMessage;
import com.birbit.android.jobqueue.messaging.message.CommandMessage;
import com.birbit.android.jobqueue.messaging.message.PublicQueryMessage;
import com.birbit.android.jobqueue.messaging.message.SchedulerMessage;
import com.birbit.android.jobqueue.scheduling.Scheduler;
import com.birbit.android.jobqueue.scheduling.SchedulerConstraint;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

public class JobManager {
    public static final long NS_PER_MS = 1000000;
    public static final long NOT_RUNNING_SESSION_ID = Long.MIN_VALUE;
    public static final long NOT_DELAYED_JOB_DELAY = Params.NEVER;
<span class="fc" id="L34">    public static final long NETWORK_CHECK_INTERVAL = TimeUnit.MILLISECONDS.toNanos(10000);</span>
    /**
     * The min delay in MS which will trigger usage of JobScheduler.
     * If a job is added with a delay in less than this value, JobManager will not use the scheduler
     * to wake up the application.
     */
    public static final long MIN_DELAY_TO_USE_SCHEDULER_IN_MS = 1000 * 30;

    final JobManagerThread jobManagerThread;
    private final PriorityMessageQueue messageQueue;
    private final MessageFactory messageFactory;
    @SuppressWarnings(&quot;FieldCanBeLocal&quot;)
    private Thread chefThread;
    @Nullable
    // this is the scheduler that was given in the configuration, not necessarily the scheduler
    // used by the JobManagerThread.
    private Scheduler scheduler;

    /**
     * Creates a JobManager with the given configuration
     *
     * @param configuration The configuration to be used for the JobManager
     *
     * @see com.birbit.android.jobqueue.config.Configuration.Builder
     */
<span class="fc" id="L59">    public JobManager(Configuration configuration) {</span>
<span class="fc" id="L60">        messageFactory = new MessageFactory();</span>
<span class="fc" id="L61">        messageQueue = new PriorityMessageQueue(configuration.getTimer(), messageFactory);</span>
<span class="fc" id="L62">        jobManagerThread = new JobManagerThread(configuration, messageQueue, messageFactory);</span>
<span class="fc" id="L63">        chefThread = new Thread(jobManagerThread, &quot;job-manager&quot;);</span>
<span class="fc bfc" id="L64" title="All 2 branches covered.">        if (configuration.getScheduler() != null) {</span>
<span class="fc" id="L65">            scheduler = configuration.getScheduler();</span>
<span class="fc" id="L66">            Scheduler.Callback callback = createSchedulerCallback();</span>
<span class="fc" id="L67">            configuration.getScheduler().init(configuration.getAppContext(), callback);</span>
        }
<span class="fc" id="L69">        chefThread.start();</span>
<span class="fc" id="L70">    }</span>

    /**
     * Returns the main thread of the JobManager.
     * &lt;p&gt;
     * This is the thread where the Jobs' onAdded methods are run.
     *
     * @return The thread used by the JobManager for its own logic.
     */
    @VisibleForTesting
    public Thread getJobManagerExecutionThread() {
<span class="fc" id="L81">        return chefThread;</span>
    }

    /**
     * The scheduler that was given to this JobManager when it was initialized.
     * &lt;p&gt;
     * The scheduler is used by the JobService to communicate with the JobManager.
     *
     * @return The scheduler that was given to this JobManager or null if it does not exist
     */
    @Nullable
    public Scheduler getScheduler() {
<span class="nc" id="L93">        return scheduler;</span>
    }

    private Scheduler.Callback createSchedulerCallback() {
<span class="fc" id="L97">        return new Scheduler.Callback() {</span>
            @Override
            public boolean start(SchedulerConstraint constraint) {
<span class="nc" id="L100">                dispatchSchedulerStart(constraint);</span>
<span class="nc" id="L101">                return true;</span>
            }

            @Override
            public boolean stop(SchedulerConstraint constraint) {
<span class="nc" id="L106">                dispatchSchedulerStop(constraint);</span>
                // always return false to avoid blocking the queue
<span class="nc" id="L108">                return false;</span>
            }
        };
    }

    private void dispatchSchedulerStart(SchedulerConstraint constraint) {
<span class="nc" id="L114">        SchedulerMessage message = messageFactory.obtain(SchedulerMessage.class);</span>
<span class="nc" id="L115">        message.set(SchedulerMessage.START, constraint);</span>
<span class="nc" id="L116">        messageQueue.post(message);</span>
<span class="nc" id="L117">    }</span>

    private void dispatchSchedulerStop(SchedulerConstraint constraint) {
<span class="nc" id="L120">        SchedulerMessage message = messageFactory.obtain(SchedulerMessage.class);</span>
<span class="nc" id="L121">        message.set(PublicQueryMessage.START, constraint);</span>
<span class="nc" id="L122">        messageQueue.post(message);</span>
<span class="nc" id="L123">    }</span>

    /**
     * Starts the JobManager if it is not already running.
     *
     * @see #stop()
     */
    public void start() {
<span class="fc" id="L131">        PublicQueryMessage message = messageFactory.obtain(PublicQueryMessage.class);</span>
<span class="fc" id="L132">        message.set(PublicQueryMessage.START, null);</span>
<span class="fc" id="L133">        messageQueue.post(message);</span>
<span class="fc" id="L134">    }</span>

    /**
     * Stops the JobManager. Currently running Jobs will continue to run but no new Jobs will be
     * run until restarted.
     *
     * @see #start()
     */
    public void stop() {
<span class="fc" id="L143">        PublicQueryMessage message = messageFactory.obtain(PublicQueryMessage.class);</span>
<span class="fc" id="L144">        message.set(PublicQueryMessage.STOP, null);</span>
<span class="fc" id="L145">        messageQueue.post(message);</span>
<span class="fc" id="L146">    }</span>

    /**
     * Returns the number of consumer threads that are currently running Jobs. This number includes
     * consumer threads that are currently idle.
     * &lt;p&gt;
     * You cannot call this method on the main thread because it may potentially block it for a long
     * time.
     * @return The number of consumer threads
     */
    public int getActiveConsumerCount() {
<span class="fc" id="L157">        assertNotInMainThread();</span>
<span class="fc" id="L158">        assertNotInJobManagerThread(&quot;Cannot call sync methods in JobManager's callback thread.&quot;);</span>
<span class="fc" id="L159">        PublicQueryMessage message = messageFactory.obtain(PublicQueryMessage.class);</span>
<span class="fc" id="L160">        message.set(PublicQueryMessage.ACTIVE_CONSUMER_COUNT, null);</span>
<span class="fc" id="L161">        return new IntQueryFuture&lt;&gt;(messageQueue, message).getSafe();</span>
    }

    /**
     * Destroys the JobManager. You cannot make any calls to this JobManager after this call.
     * Useful to be called after your tests.
     *
     * @see #stopAndWaitUntilConsumersAreFinished()
     */
    public void destroy() {
<span class="fc" id="L171">        JqLog.d(&quot;destroying job queue&quot;);</span>
<span class="fc" id="L172">        stopAndWaitUntilConsumersAreFinished();</span>
<span class="fc" id="L173">        CommandMessage message = messageFactory.obtain(CommandMessage.class);</span>
<span class="fc" id="L174">        message.set(CommandMessage.QUIT);</span>
<span class="fc" id="L175">        messageQueue.post(message);</span>
<span class="fc" id="L176">        jobManagerThread.callbackManager.destroy();</span>
<span class="fc" id="L177">    }</span>

    /**
     * Stops the JobManager and waits until all currently running Jobs are complete (or failed).
     * Useful to be called in your tests.
     * &lt;p&gt;
     * You cannot call this method on the main thread because it may potentially block it for a long
     * time.
     *
     * @see #destroy()
     */
    public void stopAndWaitUntilConsumersAreFinished() {
<span class="fc" id="L189">        waitUntilConsumersAreFinished(true);</span>
<span class="fc" id="L190">    }</span>

    /**
     * Waits until all consumers are destroyed. If min consumer count is NOT 0, this method will
     * never return.
     * &lt;p&gt;
     * You cannot call this method on the main thread because it may potentially block it for a long
     * time.
     */
    public void waitUntilConsumersAreFinished() {
<span class="fc" id="L200">        waitUntilConsumersAreFinished(false);</span>
<span class="fc" id="L201">    }</span>

    private void waitUntilConsumersAreFinished(boolean stop) {
<span class="fc" id="L204">        assertNotInMainThread();</span>
<span class="fc" id="L205">        final CountDownLatch latch = new CountDownLatch(1);</span>
<span class="fc" id="L206">        jobManagerThread.consumerManager.addNoConsumersListener(new Runnable() {</span>
            @Override
            public void run() {
<span class="fc" id="L209">                latch.countDown();</span>
<span class="fc" id="L210">                jobManagerThread.consumerManager.removeNoConsumersListener(this);</span>
<span class="fc" id="L211">            }</span>
        });
<span class="fc bfc" id="L213" title="All 2 branches covered.">        if (stop) {</span>
<span class="fc" id="L214">            stop();</span>
        }
<span class="fc bfc" id="L216" title="All 2 branches covered.">        if(jobManagerThread.consumerManager.getWorkerCount() == 0) {</span>
<span class="fc" id="L217">            return;</span>
        }
        try {
<span class="fc" id="L220">            latch.await();</span>
<span class="nc" id="L221">        } catch (InterruptedException ignored) {</span>
<span class="fc" id="L222">        }</span>
<span class="fc" id="L223">        PublicQueryMessage pm = messageFactory.obtain(PublicQueryMessage.class);</span>
<span class="fc" id="L224">        pm.set(PublicQueryMessage.CLEAR, null);</span>
<span class="fc" id="L225">        new IntQueryFuture&lt;&gt;(jobManagerThread.callbackManager.messageQueue, pm).getSafe();</span>
<span class="fc" id="L226">    }</span>

    /**
     * Adds a Job to the JobManager. This method instantly returns and does not wait until the Job
     * is added. You should always prefer this method over {@link #addJob(Job)}.
     *
     * @param job The Job to be added
     *
     * @see #addJobInBackground(Job, AsyncAddCallback)
     * @see #addJob(Job)
     */
    public void addJobInBackground(Job job) {
<span class="fc" id="L238">        AddJobMessage message = messageFactory.obtain(AddJobMessage.class);</span>
<span class="fc" id="L239">        message.setJob(job);</span>
<span class="fc" id="L240">        messageQueue.post(message);</span>
<span class="fc" id="L241">    }</span>

    /**
     * Cancels the Jobs that match the given criteria. If a Job that matches the criteria is
     * currently running, JobManager waits until it finishes its {@link Job#onRun()} method before
     * calling the callback.
     *
     * @param cancelCallback The callback to call once cancel is handled
     * @param constraint The constraint to be used to match tags
     * @param tags The list of tags
     */
    public void cancelJobsInBackground(final CancelResult.AsyncCancelCallback cancelCallback,
            final TagConstraint constraint, final String... tags) {
<span class="pc bpc" id="L254" title="1 of 2 branches missed.">        if (constraint == null) {</span>
<span class="nc" id="L255">            throw new IllegalArgumentException(&quot;must provide a TagConstraint&quot;);</span>
        }
<span class="fc" id="L257">        CancelMessage message = messageFactory.obtain(CancelMessage.class);</span>
<span class="fc" id="L258">        message.setCallback(cancelCallback);</span>
<span class="fc" id="L259">        message.setConstraint(constraint);</span>
<span class="fc" id="L260">        message.setTags(tags);</span>
<span class="fc" id="L261">        messageQueue.post(message);</span>
<span class="fc" id="L262">    }</span>

    /**
     * Adds a JobManagerCallback to observe this JobManager.
     *
     * @param callback The callback to be added
     */
    public void addCallback(JobManagerCallback callback) {
<span class="fc" id="L270">        jobManagerThread.addCallback(callback);</span>
<span class="fc" id="L271">    }</span>

    /**
     * Removes the JobManagerCallback from the callbacks list. This method is safe to be called
     * inside any method of the JobManagerCallback.
     *
     * @param callback The callback to be removed
     *
     * @return true if the callback is removed, false otherwise (if it did not exist).
     */
    public boolean removeCallback(JobManagerCallback callback) {
<span class="fc" id="L282">        return jobManagerThread.removeCallback(callback);</span>
    }

    /**
     * Adds the Job to the JobManager and waits until the add is handled.
     * &lt;p&gt;
     * You cannot call this method on the main thread because it may potentially block it for a long
     * time.
     *
     * Even if you are not on the main thread, you should prefer using
     * {@link #addJobInBackground(Job)} or {@link #addJobInBackground(Job, AsyncAddCallback)} if
     * you don't need to block your thread until the Job is actually added.
     *
     * @param job The Job to be added
     *
     * @see #addJobInBackground(Job)
     * @see #addJobInBackground(Job, AsyncAddCallback)
     */
    public void addJob(Job job) {
<span class="fc" id="L301">        assertNotInMainThread(&quot;Cannot call this method on main thread. Use addJobInBackground &quot;</span>
                + &quot;instead.&quot;);
<span class="fc" id="L303">        assertNotInJobManagerThread(&quot;Cannot call sync methods in JobManager's callback thread.&quot; +</span>
                &quot;Use addJobInBackground instead&quot;);
<span class="fc" id="L305">        final CountDownLatch latch = new CountDownLatch(1);</span>
<span class="fc" id="L306">        final String uuid = job.getId();</span>
<span class="fc" id="L307">        addCallback(new JobManagerCallbackAdapter() {</span>
            @Override
            public void onJobAdded(@NonNull Job job) {
<span class="fc bfc" id="L310" title="All 2 branches covered.">                if (uuid.equals(job.getId())) {</span>
<span class="fc" id="L311">                    latch.countDown();</span>
<span class="fc" id="L312">                    removeCallback(this);</span>
                }
<span class="fc" id="L314">            }</span>
        });
<span class="fc" id="L316">        addJobInBackground(job);</span>
        try {
<span class="fc" id="L318">            latch.await();</span>
<span class="nc" id="L319">        } catch (InterruptedException ignored) {</span>

<span class="fc" id="L321">        }</span>
<span class="fc" id="L322">    }</span>

    /**
     * Adds a Job in a background thread and calls the provided callback once the Job is added
     * to the JobManager.
     *
     * @param job The Job to be added
     * @param callback The callback to be invoked once Job is saved in the JobManager's queues
     */
    public void addJobInBackground(Job job, final AsyncAddCallback callback) {
<span class="pc bpc" id="L332" title="1 of 2 branches missed.">        if (callback == null) {</span>
<span class="nc" id="L333">            addJobInBackground(job);</span>
<span class="nc" id="L334">            return;</span>
        }
<span class="fc" id="L336">        final String uuid = job.getId();</span>
<span class="fc" id="L337">        addCallback(new JobManagerCallbackAdapter() {</span>
            @Override
            public void onJobAdded(@NonNull Job job) {
<span class="pc bpc" id="L340" title="1 of 2 branches missed.">                if (uuid.equals(job.getId())) {</span>
                    try {
<span class="fc" id="L342">                        callback.onAdded();</span>
                    } finally {
<span class="pc" id="L344">                        removeCallback(this);</span>
<span class="fc" id="L345">                    }</span>
                }
<span class="fc" id="L347">            }</span>
        });
<span class="fc" id="L349">        addJobInBackground(job);</span>
<span class="fc" id="L350">    }</span>

    /**
     * Cancels jobs that match the given criteria. This method blocks until the cancellation is
     * handled, which might be a long time if a Job that matches the given criteria is currently
     * running. Consider using
     * {@link #cancelJobsInBackground(CancelResult.AsyncCancelCallback, TagConstraint, String...)}
     * if possible.
     * &lt;p&gt;
     * You cannot call this method on the main thread because it may potentially block it for a long
     * time.
     *
     * @param constraint The constraints to be used for tags
     * @param tags The list of tags
     *
     * @return A cancel result that has the list of cancelled and failed to cancel Jobs. A job
     * might fail to cancel if it already started before cancel request is handled.
     */
    public CancelResult cancelJobs(TagConstraint constraint, String... tags) {
<span class="fc" id="L369">        assertNotInMainThread(&quot;Cannot call this method on main thread. Use cancelJobsInBackground&quot;</span>
                + &quot; instead&quot;);
<span class="fc" id="L371">        assertNotInJobManagerThread(&quot;Cannot call this method on JobManager's thread. Use&quot; +</span>
                &quot;cancelJobsInBackground instead&quot;);
<span class="pc bpc" id="L373" title="1 of 2 branches missed.">        if (constraint == null) {</span>
<span class="nc" id="L374">            throw new IllegalArgumentException(&quot;must provide a TagConstraint&quot;);</span>
        }
<span class="fc" id="L376">        final CountDownLatch latch = new CountDownLatch(1);</span>
<span class="fc" id="L377">        final CancelResult[] result = new CancelResult[1];</span>
<span class="fc" id="L378">        CancelResult.AsyncCancelCallback myCallback = new CancelResult.AsyncCancelCallback() {</span>
            @Override
            public void onCancelled(CancelResult cancelResult) {
<span class="fc" id="L381">                result[0] = cancelResult;</span>
<span class="fc" id="L382">                latch.countDown();</span>
<span class="fc" id="L383">            }</span>
        };
<span class="fc" id="L385">        CancelMessage message = messageFactory.obtain(CancelMessage.class);</span>
<span class="fc" id="L386">        message.setConstraint(constraint);</span>
<span class="fc" id="L387">        message.setTags(tags);</span>
<span class="fc" id="L388">        message.setCallback(myCallback);</span>
<span class="fc" id="L389">        messageQueue.post(message);</span>
        try {
<span class="fc" id="L391">            latch.await();</span>
<span class="nc" id="L392">        } catch (InterruptedException ignored) {</span>
<span class="fc" id="L393">        }</span>
<span class="fc" id="L394">        return result[0];</span>
    }

    /**
     * Returns the number of jobs in the JobManager. This number does not include jobs that are
     * currently running.
     * &lt;p&gt;
     * You cannot call this method on the main thread because it may potentially block it for a long
     * time.
     *
     * @return The number of jobs that are waiting to be run
     */
    public int count() {
<span class="fc" id="L407">        assertNotInMainThread();</span>
<span class="fc" id="L408">        assertNotInJobManagerThread(&quot;Cannot call count sync method in JobManager's thread&quot;);</span>
<span class="fc" id="L409">        PublicQueryMessage message = messageFactory.obtain(PublicQueryMessage.class);</span>
<span class="fc" id="L410">        message.set(PublicQueryMessage.COUNT, null);</span>
<span class="fc" id="L411">        return new IntQueryFuture&lt;&gt;(messageQueue, message).getSafe();</span>
    }

    /**
     * Returns the number of jobs that are ready to be executed but waiting in the queue.
     * &lt;p&gt;
     * You cannot call this method on the main thread because it may potentially block it for a long
     * time.
     * @return The number of jobs that are ready to be executed but waiting in the queue.
     */
    public int countReadyJobs() {
<span class="fc" id="L422">        assertNotInMainThread();</span>
<span class="fc" id="L423">        assertNotInJobManagerThread(&quot;Cannot call countReadyJobs sync method on JobManager's thread&quot;);</span>
<span class="fc" id="L424">        PublicQueryMessage message = messageFactory.obtain(PublicQueryMessage.class);</span>
<span class="fc" id="L425">        message.set(PublicQueryMessage.COUNT_READY, null);</span>
<span class="fc" id="L426">        return new IntQueryFuture&lt;&gt;(messageQueue, message).getSafe();</span>
    }

    /**
     * Returns the current status of a given job
     * &lt;p&gt;
     * You cannot call this method on the main thread because it may potentially block it for a long
     * time.
     * @param id The id of the job ({@link Job#getId()})
     *
     * @return The current status of the Job
     */
    public JobStatus getJobStatus(String id) {
<span class="fc" id="L439">        assertNotInMainThread();</span>
<span class="fc" id="L440">        assertNotInJobManagerThread(&quot;Cannot call getJobStatus on JobManager's thread&quot;);</span>
<span class="fc" id="L441">        PublicQueryMessage message = messageFactory.obtain(PublicQueryMessage.class);</span>
<span class="fc" id="L442">        message.set(PublicQueryMessage.JOB_STATUS, id, null);</span>
<span class="fc" id="L443">        Integer status = new IntQueryFuture&lt;&gt;(messageQueue, message).getSafe();</span>
<span class="fc" id="L444">        return JobStatus.values()[status];</span>
    }

    /**
     * Clears all waiting Jobs in the JobManager. Note that this won't touch any job that is
     * currently running.
     * &lt;p&gt;
     * You cannot call this method on the main thread because it may potentially block it for a long
     * time.
     */
    public void clear() {
<span class="fc" id="L455">        assertNotInMainThread();</span>
<span class="fc" id="L456">        assertNotInJobManagerThread(&quot;Cannot call clear on JobManager's thread&quot;);</span>
<span class="fc" id="L457">        final PublicQueryMessage message = messageFactory.obtain(PublicQueryMessage.class);</span>
<span class="fc" id="L458">        message.set(PublicQueryMessage.CLEAR, null);</span>
<span class="fc" id="L459">        new IntQueryFuture&lt;&gt;(messageQueue, message).getSafe();</span>
<span class="fc" id="L460">    }</span>

    void internalRunInJobManagerThread(final Runnable runnable) throws Throwable {
<span class="fc" id="L463">        final Throwable[] error = new Throwable[1];</span>
<span class="fc" id="L464">        final PublicQueryMessage message = messageFactory.obtain(PublicQueryMessage.class);</span>
<span class="fc" id="L465">        message.set(PublicQueryMessage.INTERNAL_RUNNABLE, null);</span>
<span class="fc" id="L466">        new IntQueryFuture&lt;PublicQueryMessage&gt;(messageQueue, message) {</span>
            @Override
            public void onResult(int result) { // this is hacky but allright
                try {
<span class="fc" id="L470">                    runnable.run();</span>
<span class="nc" id="L471">                } catch (Throwable t) {</span>
<span class="nc" id="L472">                    error[0] = t;</span>
<span class="fc" id="L473">                }</span>
<span class="fc" id="L474">                super.onResult(result);</span>
<span class="fc" id="L475">            }</span>
<span class="fc" id="L476">        }.getSafe();</span>
<span class="pc bpc" id="L477" title="1 of 2 branches missed.">        if (error[0] != null) {</span>
<span class="nc" id="L478">            throw error[0];</span>
        }
<span class="fc" id="L480">    }</span>

    private void assertNotInMainThread() {
<span class="fc" id="L483">        assertNotInMainThread(&quot;Cannot call this method on main thread.&quot;);</span>
<span class="fc" id="L484">    }</span>

    private void assertNotInMainThread(String message) {
<span class="pc bpc" id="L487" title="1 of 2 branches missed.">        if (Looper.getMainLooper().getThread() == Thread.currentThread()) {</span>
<span class="nc" id="L488">            throw new WrongThreadException(message);</span>
        }
<span class="fc" id="L490">    }</span>

    private void assertNotInJobManagerThread(String message) {
<span class="fc bfc" id="L493" title="All 2 branches covered.">        if (Thread.currentThread() == chefThread) {</span>
<span class="fc" id="L494">            throw new WrongThreadException(message);</span>
        }
<span class="fc" id="L496">    }</span>

    @SuppressWarnings(&quot;WeakerAccess&quot;)
    static class IntQueryFuture&lt;T extends Message &amp; IntCallback.MessageWithCallback&gt;
            implements Future&lt;Integer&gt;,IntCallback {
        final MessageQueue messageQueue;
<span class="fc" id="L502">        volatile Integer result = null;</span>
<span class="fc" id="L503">        final CountDownLatch latch = new CountDownLatch(1);</span>
        final T message;

<span class="fc" id="L506">        IntQueryFuture(MessageQueue messageQueue, T message) {</span>
<span class="fc" id="L507">            this.messageQueue = messageQueue;</span>
<span class="fc" id="L508">            this.message = message;</span>
<span class="fc" id="L509">            message.setCallback(this);</span>
<span class="fc" id="L510">        }</span>

        @Override
        public boolean cancel(boolean mayInterruptIfRunning) {
<span class="nc" id="L514">            return false;</span>
        }

        @Override
        public boolean isCancelled() {
<span class="nc" id="L519">            return false;</span>
        }

        @Override
        public boolean isDone() {
<span class="nc bnc" id="L524" title="All 2 branches missed.">            return latch.getCount() == 0;</span>
        }

        Integer getSafe() {
            try {
<span class="fc" id="L529">                return get();</span>
<span class="nc" id="L530">            } catch (Throwable t) {</span>
<span class="nc" id="L531">                JqLog.e(t, &quot;message is not complete&quot;);</span>
            }
<span class="nc" id="L533">            throw new RuntimeException(&quot;cannot get the result of the JobManager query&quot;);</span>
        }

        @Override
        public Integer get() throws InterruptedException, ExecutionException {
<span class="fc" id="L538">            messageQueue.post(message);</span>
<span class="fc" id="L539">            latch.await();</span>
<span class="fc" id="L540">            return result;</span>
        }

        @Override
        public Integer get(long timeout, @NonNull TimeUnit unit)
                throws InterruptedException, ExecutionException, TimeoutException {
<span class="nc" id="L546">            messageQueue.post(message);</span>
<span class="nc" id="L547">            latch.await(timeout, unit);</span>
<span class="nc" id="L548">            return result;</span>
        }

        @Override
        public void onResult(int result) {
<span class="fc" id="L553">            this.result = result;</span>
<span class="fc" id="L554">            latch.countDown();</span>
<span class="fc" id="L555">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.1.201405082137</span></div></body></html>