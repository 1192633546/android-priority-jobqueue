<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>JobConsumerExecutor.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jobqueue</a> &gt; <a href="index.source.html" class="el_package">com.path.android.jobqueue.executor</a> &gt; <span class="el_source">JobConsumerExecutor.java</span></div><h1>JobConsumerExecutor.java</h1><pre class="source lang-java linenums">package com.path.android.jobqueue.executor;

import com.path.android.jobqueue.Job;
import com.path.android.jobqueue.JobHolder;
import com.path.android.jobqueue.JobManager;
import com.path.android.jobqueue.JobQueue;
import com.path.android.jobqueue.TagConstraint;
import com.path.android.jobqueue.config.Configuration;
import com.path.android.jobqueue.log.JqLog;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * An executor class that takes care of spinning consumer threads and making sure enough is alive.
 * works deeply coupled with {@link JobManager}
 */
public class JobConsumerExecutor {
    private int maxConsumerSize;
    private int minConsumerSize;
    private int loadFactor;
    private final ThreadGroup threadGroup;
    private final Contract contract;
    private final int keepAliveSeconds;
<span class="fc" id="L30">    private final AtomicInteger activeConsumerCount = new AtomicInteger(0);</span>
    // key : id + (isPersistent)
    private final ConcurrentHashMap&lt;String, JobHolder&gt; runningJobHolders;


<span class="fc" id="L35">    public JobConsumerExecutor(Configuration config, Contract contract) {</span>
<span class="fc" id="L36">        this.loadFactor = config.getLoadFactor();</span>
<span class="fc" id="L37">        this.maxConsumerSize = config.getMaxConsumerCount();</span>
<span class="fc" id="L38">        this.minConsumerSize = config.getMinConsumerCount();</span>
<span class="fc" id="L39">        this.keepAliveSeconds = config.getConsumerKeepAlive();</span>
<span class="fc" id="L40">        this.contract = contract;</span>
<span class="fc" id="L41">        threadGroup = new ThreadGroup(&quot;JobConsumers&quot;);</span>
<span class="fc" id="L42">        runningJobHolders = new ConcurrentHashMap&lt;String, JobHolder&gt;();</span>
<span class="fc" id="L43">    }</span>

    /**
     * creates a new consumer thread if needed.
     */
    public void considerAddingConsumer() {
<span class="fc" id="L49">        doINeedANewThread(false, true);</span>
<span class="fc" id="L50">    }</span>

    private boolean canIDie() {
<span class="fc bfc" id="L53" title="All 2 branches covered.">        if(doINeedANewThread(true, false) == false) {</span>
<span class="fc" id="L54">            return true;</span>
        }
<span class="fc" id="L56">        return false;</span>
    }

    private boolean doINeedANewThread(boolean inConsumerThread, boolean addIfNeeded) {
        //if network provider cannot notify us, we have to busy wait
<span class="fc bfc" id="L61" title="All 2 branches covered.">        if(contract.isRunning() == false) {</span>
<span class="fc bfc" id="L62" title="All 2 branches covered.">            if(inConsumerThread) {</span>
<span class="fc" id="L63">                activeConsumerCount.decrementAndGet();</span>
            }
<span class="fc" id="L65">            return false;</span>
        }

<span class="fc" id="L68">        synchronized (threadGroup) {</span>
<span class="fc bfc" id="L69" title="All 4 branches covered.">            if(isAboveLoadFactor(inConsumerThread) &amp;&amp; canAddMoreConsumers()) {</span>
<span class="fc bfc" id="L70" title="All 2 branches covered.">                if(addIfNeeded) {</span>
<span class="fc" id="L71">                    addConsumer();</span>
                }
<span class="fc" id="L73">                return true;</span>
            }
<span class="pc" id="L75">        }</span>
<span class="fc bfc" id="L76" title="All 2 branches covered.">        if(inConsumerThread) {</span>
<span class="fc" id="L77">            activeConsumerCount.decrementAndGet();</span>
        }
<span class="fc" id="L79">        return false;</span>
    }

    private void addConsumer() {
<span class="fc" id="L83">        JqLog.d(&quot;adding another consumer&quot;);</span>
<span class="fc" id="L84">        synchronized (threadGroup) {</span>
<span class="fc" id="L85">            Thread thread = new Thread(threadGroup, new JobConsumer(contract, this));</span>
<span class="fc" id="L86">            activeConsumerCount.incrementAndGet();</span>
<span class="fc" id="L87">            thread.start();</span>
<span class="pc" id="L88">        }</span>
<span class="fc" id="L89">    }</span>

    private boolean canAddMoreConsumers() {
<span class="fc" id="L92">        synchronized (threadGroup) {</span>
            //there is a race condition for the time thread if about to finish
<span class="fc bfc" id="L94" title="All 2 branches covered.">            return activeConsumerCount.intValue() &lt; maxConsumerSize;</span>
<span class="nc" id="L95">        }</span>
    }

    private boolean isAboveLoadFactor(boolean inConsumerThread) {
<span class="fc" id="L99">        synchronized (threadGroup) {</span>
            //if i am called from a consumer thread, don't count me
<span class="fc bfc" id="L101" title="All 2 branches covered.">            int consumerCnt = activeConsumerCount.intValue() - (inConsumerThread ? 1 : 0);</span>
<span class="fc bfc" id="L102" title="All 4 branches covered.">            boolean res =</span>
                    consumerCnt &lt; minConsumerSize ||
                    consumerCnt * loadFactor &lt; contract.countRemainingReadyJobs() + runningJobHolders.size();
<span class="fc bfc" id="L105" title="All 2 branches covered.">            if(JqLog.isDebugEnabled()) {</span>
<span class="fc" id="L106">                JqLog.d(&quot;%s: load factor check. %s = (%d &lt; %d)|| (%d * %d &lt; %d + %d). consumer thread: %s&quot;, Thread.currentThread().getName(), res,</span>
                        consumerCnt, minConsumerSize,
                        consumerCnt, loadFactor, contract.countRemainingReadyJobs(), runningJobHolders.size(), inConsumerThread);
            }
<span class="fc" id="L110">            return res;</span>
<span class="nc" id="L111">        }</span>

    }

    private void onBeforeRun(JobHolder jobHolder) {
<span class="fc" id="L116">        synchronized (runningJobHolders) {</span>
<span class="fc" id="L117">            runningJobHolders.put(createRunningJobHolderKey(jobHolder), jobHolder);</span>
<span class="pc" id="L118">        }</span>
<span class="fc" id="L119">    }</span>

    private void onAfterRun(JobHolder jobHolder) {
<span class="fc" id="L122">        synchronized (runningJobHolders) {</span>
<span class="fc" id="L123">            runningJobHolders.remove(createRunningJobHolderKey(jobHolder));</span>
<span class="fc" id="L124">            runningJobHolders.notifyAll();</span>
<span class="pc" id="L125">        }</span>
<span class="fc" id="L126">    }</span>

    private String createRunningJobHolderKey(JobHolder jobHolder) {
<span class="fc" id="L129">        return createRunningJobHolderKey(jobHolder.getId(), jobHolder.getJob().isPersistent());</span>
    }

    private String createRunningJobHolderKey(long id, boolean isPersistent) {
<span class="fc bfc" id="L133" title="All 2 branches covered.">        return id + &quot;_&quot; + (isPersistent ? &quot;t&quot; : &quot;f&quot;);</span>
    }

    /**
     * returns true if job is currently handled by one of the executor threads
     * @param id id of the job
     * @param persistent boolean flag to distinguish id conflicts
     * @return true if job is currently handled here
     */
    public boolean isRunning(long id, boolean persistent) {
<span class="fc" id="L143">        synchronized (runningJobHolders) {</span>
<span class="fc" id="L144">            return runningJobHolders.containsKey(createRunningJobHolderKey(id, persistent));</span>
<span class="nc" id="L145">        }</span>
    }

    public void waitUntilDone(Set&lt;Long&gt; persistentJobIds, Set&lt;Long&gt; nonPersistentJobIds)
            throws InterruptedException {
<span class="fc" id="L150">        List&lt;String&gt; ids = new ArrayList&lt;String&gt;();</span>
<span class="fc bfc" id="L151" title="All 2 branches covered.">        for (Long id : persistentJobIds) {</span>
<span class="fc" id="L152">            ids.add(createRunningJobHolderKey(id, true));</span>
<span class="fc" id="L153">        }</span>
<span class="fc bfc" id="L154" title="All 2 branches covered.">        for (Long id : nonPersistentJobIds) {</span>
<span class="fc" id="L155">            ids.add(createRunningJobHolderKey(id, false));</span>
<span class="fc" id="L156">        }</span>
<span class="fc" id="L157">        synchronized (runningJobHolders) {</span>
<span class="fc bfc" id="L158" title="All 2 branches covered.">            while (containsAny(ids)) {</span>
<span class="fc" id="L159">                runningJobHolders.wait();</span>
            }
<span class="pc" id="L161">        }</span>
<span class="fc" id="L162">    }</span>

    private boolean containsAny(List&lt;String&gt; ids) {
<span class="fc bfc" id="L165" title="All 2 branches covered.">        for (String id : ids) {</span>
<span class="fc bfc" id="L166" title="All 2 branches covered.">            if (runningJobHolders.containsKey(id)) {</span>
<span class="fc" id="L167">                return true;</span>
            }
<span class="fc" id="L169">        }</span>
<span class="fc" id="L170">        return false;</span>
    }

    public void inRunningJobHoldersLock(Runnable runnable) {
<span class="fc" id="L174">        synchronized (runnable) {</span>
<span class="fc" id="L175">            runnable.run();;</span>
<span class="pc" id="L176">        }</span>
<span class="fc" id="L177">    }</span>

    /**
     * Excludes cancelled jobs
     */
    public Set&lt;JobHolder&gt; findRunningByTags(TagConstraint constraint, String[] tags,
            boolean persistent) {
<span class="fc" id="L184">        Set&lt;JobHolder&gt; result = new HashSet&lt;JobHolder&gt;();</span>
<span class="fc" id="L185">        synchronized (runningJobHolders) {</span>
<span class="fc bfc" id="L186" title="All 2 branches covered.">            for (JobHolder holder : runningJobHolders.values()) {</span>
<span class="fc" id="L187">                JqLog.d(&quot;checking job tag %s. tags of job: %s&quot;, holder.getJob(), holder.getJob().getTags());</span>
<span class="fc bfc" id="L188" title="All 4 branches covered.">                if (!holder.hasTags() || persistent != holder.getJob().isPersistent()) {</span>
<span class="fc" id="L189">                    continue;</span>
                }
<span class="pc bpc" id="L191" title="1 of 2 branches missed.">                if (holder.isCancelled()) {</span>
<span class="nc" id="L192">                    continue;</span>
                }
<span class="pc bpc" id="L194" title="1 of 2 branches missed.">                if (doesHolderMatchTags(holder, constraint, tags)) {</span>
<span class="fc" id="L195">                    result.add(holder);</span>
                }
<span class="fc" id="L197">            }</span>
<span class="pc" id="L198">        }</span>
<span class="fc" id="L199">        return result;</span>
    }

    private boolean doesHolderMatchTags(JobHolder holder, TagConstraint constraint, String[] tags) {
<span class="fc bfc" id="L203" title="All 2 branches covered.">        if (constraint == TagConstraint.ANY) {</span>
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">            for (String tag : holder.getTags()) {</span>
<span class="pc bpc" id="L205" title="1 of 2 branches missed.">                if (contains(tags, tag)) {</span>
<span class="fc" id="L206">                    return true;</span>
                }
<span class="nc" id="L208">            }</span>
<span class="nc" id="L209">            return false;</span>
        } else {
<span class="fc" id="L211">            final Set&lt;String&gt; holderTags = holder.getTags();</span>
<span class="fc bfc" id="L212" title="All 2 branches covered.">            for (String tag : tags) {</span>
<span class="pc bpc" id="L213" title="1 of 2 branches missed.">                if (!holderTags.contains(tag)) {</span>
<span class="nc" id="L214">                    return false;</span>
                }
            }
<span class="fc" id="L217">            return true;</span>
        }
    }

    private boolean contains(String[] arr, String val) {
<span class="pc bpc" id="L222" title="1 of 2 branches missed.">        for (int i = 0; i &lt; arr.length; i ++) {</span>
<span class="pc bpc" id="L223" title="1 of 2 branches missed.">            if (val.equals(arr[i])) {</span>
<span class="fc" id="L224">                return true;</span>
            }
        }
<span class="nc" id="L227">        return false;</span>
    }

    public void waitUntilAllConsumersAreFinished() throws InterruptedException {
<span class="fc" id="L231">        Thread[] threads = new Thread[threadGroup.activeCount() * 3];</span>
<span class="fc" id="L232">        threadGroup.enumerate(threads);</span>
<span class="fc bfc" id="L233" title="All 2 branches covered.">        for (Thread thread : threads) {</span>
<span class="fc bfc" id="L234" title="All 2 branches covered.">            if (thread != null) {</span>
<span class="fc" id="L235">                thread.join();</span>
            }
        }
<span class="fc" id="L238">    }</span>

    /**
     * contract between the {@link JobManager} and {@link JobConsumerExecutor}
     */
    public static interface Contract {
        /**
         * @return if {@link JobManager} is currently running.
         */
        public boolean isRunning();

        /**
         * should insert the given {@link JobHolder} to related {@link JobQueue}. if it already exists, should replace the
         * existing one.
         * @param jobHolder
         */
        public void insertOrReplace(JobHolder jobHolder);

        /**
         * should remove the job from the related {@link JobQueue}
         * @param jobHolder
         */
        public void removeJob(JobHolder jobHolder);

        /**
         * should return the next job which is available to be run.
         * @param wait
         * @param waitUnit
         * @return next job to execute or null if no jobs are available
         */
        public JobHolder getNextJob(int wait, TimeUnit waitUnit);

        /**
         * @return the number of Jobs that are ready to be run
         */
        public int countRemainingReadyJobs();
    }

    /**
     * a simple {@link Runnable} that can take jobs from the {@link Contract} and execute them
     */
    private static class JobConsumer implements Runnable {
        private final Contract contract;
        private final JobConsumerExecutor executor;
<span class="fc" id="L282">        private boolean didRunOnce = false;</span>
<span class="fc" id="L283">        public JobConsumer(Contract contract, JobConsumerExecutor executor) {</span>
<span class="fc" id="L284">            this.executor = executor;</span>
<span class="fc" id="L285">            this.contract = contract;</span>
<span class="fc" id="L286">        }</span>

        @Override
        public void run() {
            boolean canDie;
            do {
                try {
<span class="fc bfc" id="L293" title="All 2 branches covered.">                    if(JqLog.isDebugEnabled()) {</span>
<span class="pc bpc" id="L294" title="1 of 2 branches missed.">                        if(didRunOnce == false) {</span>
<span class="fc" id="L295">                            JqLog.d(&quot;starting consumer %s&quot;, Thread.currentThread().getName());</span>
<span class="fc" id="L296">                            didRunOnce = true;</span>
                        } else {
<span class="nc" id="L298">                            JqLog.d(&quot;re-running consumer %s&quot;, Thread.currentThread().getName());</span>
                        }
                    }
                    JobHolder nextJob;
                    do {
<span class="fc bfc" id="L303" title="All 2 branches covered.">                        nextJob = contract.isRunning() ? contract.getNextJob(executor.keepAliveSeconds, TimeUnit.SECONDS) : null;</span>
<span class="fc bfc" id="L304" title="All 2 branches covered.">                        if (nextJob != null) {</span>
<span class="fc" id="L305">                            executor.onBeforeRun(nextJob);</span>
<span class="fc" id="L306">                            int result = nextJob.safeRun(nextJob.getRunCount());</span>
<span class="pc bpc" id="L307" title="1 of 5 branches missed.">                            switch (result) {</span>
                                case JobHolder.RUN_RESULT_SUCCESS:
<span class="fc" id="L309">                                    nextJob.markAsSuccessful();</span>
<span class="fc" id="L310">                                    contract.removeJob(nextJob);</span>
<span class="fc" id="L311">                                    break;</span>
                                case JobHolder.RUN_RESULT_FAIL_RUN_LIMIT:
<span class="fc" id="L313">                                    contract.removeJob(nextJob);</span>
<span class="fc" id="L314">                                    break;</span>
                                case JobHolder.RUN_RESULT_TRY_AGAIN:
<span class="fc" id="L316">                                    contract.insertOrReplace(nextJob);</span>
<span class="fc" id="L317">                                    break;</span>
                                case JobHolder.RUN_RESULT_FAIL_FOR_CANCEL:
<span class="fc" id="L319">                                    JqLog.d(&quot;running job failed and cancelled, doing nothing. &quot;</span>
                                            + &quot;Will be removed after it's onCancel is called by the &quot;
                                            + &quot;JobManager&quot;);
                                    break;
                            }
<span class="fc" id="L324">                            executor.onAfterRun(nextJob);</span>
                        }
<span class="fc bfc" id="L326" title="All 2 branches covered.">                    } while (nextJob != null);</span>
                } finally {
                    //to avoid creating a new thread for no reason, consider not killing this one first
<span class="pc" id="L329">                    canDie = executor.canIDie();</span>
<span class="pc bpc" id="L330" title="2 of 4 branches missed.">                    if(JqLog.isDebugEnabled()) {</span>
<span class="pc bpc" id="L331" title="3 of 4 branches missed.">                        if(canDie) {</span>
<span class="pc" id="L332">                            JqLog.d(&quot;finishing consumer %s&quot;, Thread.currentThread().getName());</span>
                        } else {
<span class="nc" id="L334">                            JqLog.d(&quot;didn't allow me to die, re-running %s&quot;, Thread.currentThread().getName());</span>
                        }
                    }
                }
<span class="fc bfc" id="L338" title="All 2 branches covered.">            } while (!canDie);</span>
<span class="fc" id="L339">        }</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.1.201405082137</span></div></body></html>