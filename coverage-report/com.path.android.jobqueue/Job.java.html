<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>Job.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jobqueue</a> &gt; <a href="index.source.html" class="el_package">com.path.android.jobqueue</a> &gt; <span class="el_source">Job.java</span></div><h1>Job.java</h1><pre class="source lang-java linenums">package com.path.android.jobqueue;

import com.path.android.jobqueue.log.JqLog;

import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.util.Collections;
import java.util.HashSet;
import java.util.Set;

/**
 * Base class for all of your jobs.
 */
@SuppressWarnings(&quot;deprecation&quot;)
abstract public class Job implements Serializable {
    private static final long serialVersionUID = 3L;
    public static final int DEFAULT_RETRY_LIMIT = 20;

    private boolean requiresNetwork;
    private String groupId;
    private boolean persistent;
    private Set&lt;String&gt; readonlyTags;

    private transient int currentRunCount;
    private transient int priority;
    private transient long delayInMs;
    transient boolean cancelled;


<span class="fc" id="L32">    protected Job(Params params) {</span>
<span class="fc" id="L33">        this.requiresNetwork = params.doesRequireNetwork();</span>
<span class="fc" id="L34">        this.persistent = params.isPersistent();</span>
<span class="fc" id="L35">        this.groupId = params.getGroupId();</span>
<span class="fc" id="L36">        this.priority = params.getPriority();</span>
<span class="fc" id="L37">        this.delayInMs = params.getDelayMs();</span>
<span class="fc" id="L38">        final Set&lt;String&gt; tags = params.getTags();</span>
<span class="fc bfc" id="L39" title="All 2 branches covered.">        this.readonlyTags = tags == null ? null : Collections.unmodifiableSet(tags);</span>
<span class="fc" id="L40">    }</span>

    /**
     * used by {@link JobManager} to assign proper priority at the time job is added.
     * This field is not preserved!
     * @return priority (higher = better)
     */
    public final int getPriority() {
<span class="fc" id="L48">        return priority;</span>
    }

    /**
     * used by {@link JobManager} to assign proper delay at the time job is added.
     * This field is not preserved!
     * @return delay in ms
     */
    public final long getDelayInMs() {
<span class="fc" id="L57">        return delayInMs;</span>
    }

    /**
     * Returns a readonly set of tags attached to this Job.
     * @return Set of Tags. If tags do not exists, returns null.
     */
    public final Set&lt;String&gt; getTags() {
<span class="fc" id="L65">        return readonlyTags;</span>
    }

    private void writeObject(ObjectOutputStream oos) throws IOException {
<span class="fc" id="L69">        oos.writeBoolean(requiresNetwork);</span>
<span class="fc" id="L70">        oos.writeObject(groupId);</span>
<span class="fc" id="L71">        oos.writeBoolean(persistent);</span>
<span class="fc bfc" id="L72" title="All 2 branches covered.">        final int tagCount = readonlyTags == null ? 0 : readonlyTags.size();</span>
<span class="fc" id="L73">        oos.writeInt(tagCount);</span>
<span class="fc bfc" id="L74" title="All 2 branches covered.">        if (tagCount &gt; 0) {</span>
<span class="fc bfc" id="L75" title="All 2 branches covered.">            for (String tag : readonlyTags) {</span>
<span class="fc" id="L76">                oos.writeUTF(tag);</span>
<span class="fc" id="L77">            }</span>
        }
<span class="fc" id="L79">    }</span>


    private void readObject(ObjectInputStream ois) throws ClassNotFoundException, IOException {
<span class="fc" id="L83">        requiresNetwork = ois.readBoolean();</span>
<span class="fc" id="L84">        groupId = (String) ois.readObject();</span>
<span class="fc" id="L85">        persistent = ois.readBoolean();</span>
<span class="fc" id="L86">        final int tagCount = ois.readInt();</span>
<span class="fc bfc" id="L87" title="All 2 branches covered.">        if (tagCount &gt; 0) {</span>
<span class="fc" id="L88">            readonlyTags = new HashSet&lt;String&gt;(tagCount);</span>
<span class="fc bfc" id="L89" title="All 2 branches covered.">            for (int i = 0; i &lt; tagCount; i ++) {</span>
<span class="fc" id="L90">                readonlyTags.add(ois.readUTF());</span>
            }
        }
<span class="fc" id="L93">    }</span>

    /**
     * defines if we should add this job to disk or non-persistent queue
     */
    public final boolean isPersistent() {
<span class="fc" id="L99">        return persistent;</span>
    }

    /**
     * Called when the job is added to disk and committed.
     * This means job will eventually run. This is a good time to update local database and dispatch events.
     * &lt;p&gt;
     * Changes to this class will not be preserved if your job is persistent !!!
     * &lt;p&gt;
     * Also, if your app crashes right after adding the job, {@code onRun} might be called without an {@code onAdded} call
     */
    abstract public void onAdded();

    /**
     * The actual method that should to the work.
     * It should finish w/o any exception. If it throws any exception, {@code shouldReRunOnThrowable} will be called to
     * decide either to dismiss the job or re-run it.
     * @throws Throwable
     */
    abstract public void onRun() throws Throwable;

    /**
     * Called when a job is cancelled.
     */
    abstract protected void onCancel();

    /**
     * If {@code onRun} method throws an exception, this method is called.
     * return true if you want to run your job again, return false if you want to dismiss it. If you return false,
     * onCancel will be called.
     */
    abstract protected boolean shouldReRunOnThrowable(Throwable throwable);

    /**
     * Runs the job and catches any exception
     * @param currentRunCount
     * @return one of the RUN_RESULT ints
     */
    final int safeRun(JobHolder holder, int currentRunCount) {
<span class="fc" id="L138">        this.currentRunCount = currentRunCount;</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">        if (JqLog.isDebugEnabled()) {</span>
<span class="fc" id="L140">            JqLog.d(&quot;running job %s&quot;, this.getClass().getSimpleName());</span>
        }
<span class="fc" id="L142">        boolean reRun = false;</span>
<span class="fc" id="L143">        boolean failed = false;</span>
        try {
<span class="fc" id="L145">            onRun();</span>
<span class="fc bfc" id="L146" title="All 2 branches covered.">            if (JqLog.isDebugEnabled()) {</span>
<span class="fc" id="L147">                JqLog.d(&quot;finished job %s&quot;, this);</span>
            }
<span class="fc" id="L149">        } catch (Throwable t) {</span>
<span class="fc" id="L150">            failed = true;</span>
<span class="fc" id="L151">            JqLog.e(t, &quot;error while executing job %s&quot;, this);</span>
<span class="fc bfc" id="L152" title="All 2 branches covered.">            reRun = currentRunCount &lt; getRetryLimit();</span>
<span class="fc bfc" id="L153" title="All 4 branches covered.">            if(reRun &amp;&amp; !cancelled) {</span>
                try {
<span class="fc" id="L155">                    reRun = shouldReRunOnThrowable(t);</span>
<span class="nc" id="L156">                } catch (Throwable t2) {</span>
<span class="nc" id="L157">                    JqLog.e(t2, &quot;shouldReRunOnThrowable did throw an exception&quot;);</span>
<span class="fc" id="L158">                }</span>
            }
<span class="fc" id="L160">        }</span>
<span class="fc bfc" id="L161" title="All 2 branches covered.">        JqLog.d(&quot;safeRunResult for %s : %s. re run:%s. cancelled: %s&quot;, this, !failed, reRun, cancelled);</span>
<span class="fc bfc" id="L162" title="All 2 branches covered.">        if (!failed) {</span>
<span class="fc" id="L163">            return JobHolder.RUN_RESULT_SUCCESS;</span>
        }
<span class="fc bfc" id="L165" title="All 2 branches covered.">        if (holder.isCancelled()) {</span>
<span class="fc" id="L166">            return JobHolder.RUN_RESULT_FAIL_FOR_CANCEL;</span>
        }
<span class="fc bfc" id="L168" title="All 2 branches covered.">        if (reRun) {</span>
<span class="fc" id="L169">            return JobHolder.RUN_RESULT_TRY_AGAIN;</span>
        }
        // failed.
        try {
<span class="fc" id="L173">            onCancel();</span>
<span class="nc" id="L174">        } catch (Throwable ignored) {</span>
<span class="fc" id="L175">        }</span>
<span class="fc" id="L176">        return JobHolder.RUN_RESULT_FAIL_RUN_LIMIT;</span>

    }

    /**
     * before each run, JobManager sets this number. Might be useful for the {@link com.path.android.jobqueue.Job#onRun()}
     * method
     */
    protected int getCurrentRunCount() {
<span class="fc" id="L185">        return currentRunCount;</span>
    }

    /**
     * if job is set to require network, it will not be called unless {@link com.path.android.jobqueue.network.NetworkUtil}
     * reports that there is a network connection
     */
    public final boolean requiresNetwork() {
<span class="fc" id="L193">        return requiresNetwork;</span>
    }

    /**
     * Some jobs may require being run synchronously. For instance, if it is a job like sending a comment, we should
     * never run them in parallel (unless they are being sent to different conversations).
     * By assigning same groupId to jobs, you can ensure that that type of jobs will be run in the order they were given
     * (if their priority is the same).
     * @return
     */
    public final String getRunGroupId() {
<span class="fc" id="L204">        return groupId;</span>
    }

    /**
     * By default, jobs will be retried {@code DEFAULT_RETRY_LIMIT}  times.
     * If job fails this many times, onCancel will be called w/o calling {@code shouldReRunOnThrowable}
     * @return
     */
    protected int getRetryLimit() {
<span class="fc" id="L213">        return DEFAULT_RETRY_LIMIT;</span>
    }

    /**
     * Returns true if job is cancelled. Note that if the job is already running when it is cancelled,
     * this flag is still set to true but job is NOT STOPPED (e.g. JobManager does not interrupt
     * the thread).
     * If you have a long job that may be cancelled, you can check this field and handle it manually.
     * &lt;p&gt;
     * Note that, if your job returns successfully from {@link #onRun()} method, it will be considered
     * as successfully completed, thus will be added to {@link CancelResult#getFailedToCancel()}
     * list. If you want this job to be considered as cancelled, you should throw an exception.
     * You can also use {@link #assertNotCancelled()} method to do it.
     * &lt;p&gt;
     * Calling this method outside {@link #onRun()} method has no meaning since {@link #onRun()} will not
     * be called if the job is cancelled before it is called.
     */
    public boolean isCancelled() {
<span class="nc" id="L231">        return cancelled;</span>
    }

    /**
     * Convenience method that checks if job is cancelled and throws a RuntimeException if it is
     * cancelled.
     */
    public void assertNotCancelled() {
<span class="nc bnc" id="L239" title="All 2 branches missed.">        if (cancelled) {</span>
<span class="nc" id="L240">            throw new RuntimeException(&quot;job is cancelled&quot;);</span>
        }
<span class="nc" id="L242">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.1.201405082137</span></div></body></html>