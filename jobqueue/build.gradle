import java.util.regex.Pattern
import com.amazonaws.services.s3.AmazonS3
import com.amazonaws.services.s3.AmazonS3Client
import com.amazonaws.regions.Region
import com.amazonaws.regions.Regions
import com.amazonaws.auth.AWSCredentials
import com.amazonaws.auth.BasicAWSCredentials
import com.amazonaws.services.s3.model.Bucket
apply plugin: 'com.android.library'

class UploadToS3Task extends DefaultTask {
    FileTree fileList;
    String outputPath;
    def filter;

    def getBuildNumber() {
        return System.getenv().get("TRAVIS_BUILD_NUMBER");
    }

    def getArtifactsKey() {
        return System.getenv().get("ARTIFACTS_KEY");
    }

    def getArtifactsSecret() {
        return System.getenv().get("ARTIFACTS_SECRET");
    }

    def isTravis() {
        System.getenv().get("TRAVIS") == "true";
    }

    @TaskAction
    def doUpload() {
        println "uploading files to s3"

        def loginKey = getArtifactsKey()
        def loginSecret = getArtifactsSecret()
        def buildNumber = getBuildNumber()
        if (loginKey == null || loginSecret == null || buildNumber == null || !isTravis()) {
            println "skipping upload"
            return
        }
        BasicAWSCredentials creds = new BasicAWSCredentials(loginKey, loginSecret)
        AmazonS3 s3 = new AmazonS3Client(creds);

        def path = "build-${ buildNumber}/$outputPath"
        def buildPath = project.getBuildDir().canonicalPath
        def selected = filter == null ? fileList : fileList.filter(filter)
        selected.each {
            def key = "/${it.name}"
            if (it.absolutePath.startsWith(buildPath)) {
                key = it.absolutePath.substring(buildPath.length())
            }
            def fullKey = "$path$key"
            println "uploading ${it.canonicalPath} to $fullKey"
            try {
                s3.putObject("jobqueue", fullKey, it)
            } catch (Throwable t) {
                println "errorwhile uploading to s3, skipping ${it.canonicalPath}"
            }
        }
    }
}
Properties releaseConfig = new Properties()
File releaseFile = new File("${projectDir}/releaseConfig.properties")
if (releaseFile.exists()) {
    releaseConfig.load(new FileInputStream(releaseFile))
}

ext.releaseConfig = releaseConfig

task wrapper(type: Wrapper) {
    gradleVersion = '2.10'
}

apply plugin: 'maven'
apply plugin: 'signing'
apply plugin: 'jacoco'



buildscript {
    repositories {
        jcenter()
    }

    dependencies {
        classpath 'com.android.tools.build:gradle:1.5.0'
        classpath 'com.amazonaws:aws-java-sdk-s3:1.10.50'
    }
}

repositories {
    mavenCentral()
    jcenter()
    maven { url "https://oss.sonatype.org/content/repositories/snapshots" }
}

configurations {
    archives {
        extendsFrom configurations.default
    }
}

dependencies {
    testCompile 'junit:junit:4.12'
    testCompile "org.robolectric:robolectric:3.0"
    testCompile 'org.hamcrest:hamcrest-core:1.3'
    testCompile 'org.easytesting:fest-util:1.2.5'
    testCompile 'org.easytesting:fest-reflect:1.4.1'
    testCompile 'org.mockito:mockito-core:2.0.2-beta'
    // use an old version since we only need a few util classes that were already there for a long
    // time. If app depends on a newer one, gradle will pick it for us.
    compile 'com.android.support:support-v4:21.0.3'
}

android {
    compileSdkVersion 23
    buildToolsVersion "23.0.2"
    buildTypes {
        debug {
            testCoverageEnabled = true
        }
    }

    defaultConfig {
        minSdkVersion 7
        targetSdkVersion 23
    }
}

//READ VERSION NAME
def manifestFile = file("${projectDir}/src/main/AndroidManifest.xml")
def pattern = Pattern.compile("versionName=\"([\\d\\.\\w\\-]+)\"")
def manifestText = manifestFile.getText()
def matcher = pattern.matcher(manifestText)
matcher.find()
def manifestVersionName = matcher.group(1)
println "version name:${manifestVersionName}"

//create jar tasks

android.libraryVariants.all { variant ->
    def name = variant.buildType.name
    println "checking variant ${name}"
    if (variant.buildType.isDebuggable()) {
        return; // Skip debug builds.
    }
    def suffix = name.capitalize()
    println "found release variant"
    def jarTask = project.tasks.create(name: "jar${suffix}", type: Jar){
        dependsOn variant.javaCompile
        from variant.javaCompile.destinationDir
        from 'LICENSE.txt'
    }
    def javadocTask = project.tasks.create(name: "javadoc${suffix}", type: Javadoc) {
        source = variant.javaCompile.source
        ext.androidJar = "${android.sdkDirectory}/platforms/${android.compileSdkVersion}/android.jar"
        classpath = files(variant.javaCompile.classpath.files) + files(ext.androidJar)
    }

    def javadocJarTask = project.tasks.create(name: "javadocJar${suffix}", type: Jar) {
        classifier = 'javadoc'
        from 'build/docs/javadoc'
    }

    def sourcesJarTask = project.tasks.create(name: "sourceJar${suffix}", type: Jar) {
        from android.sourceSets.main.getJava().getSrcDirs()
        classifier = 'sources'
    }
    artifacts.add('archives', jarTask);
    artifacts.add('archives', javadocJarTask);
    artifacts.add('archives', sourcesJarTask);
}
//create jar tasks end

afterEvaluate { project ->
    uploadArchives {
        repositories {
            mavenDeployer {
                beforeDeployment {
                    MavenDeployment deployment -> signing.signPom(deployment)
                }
                println "ossr username: ${releaseConfig.ossrhUsername}"

                pom.artifactId = 'android-priority-jobqueue'


//                snapshotRepository(url: "https://oss.sonatype.org/content/repositories/snapshots") {
//                    authentication(userName: releaseConfig.ossrhUsername, password: releaseConfig.ossrhPassword)
//                }
                snapshotRepository(url: mavenLocal().url) {

                }

                repository(url: "https://oss.sonatype.org/service/local/staging/deploy/maven2") {
                    authentication(userName: releaseConfig.ossrhUsername, password: releaseConfig.ossrhPassword)
                }

                pom.project {
                    modelVersion '4.0.0'
                    groupId 'com.birbit'
                    artifactId 'android-priority-jobqueue'
                    packaging 'jar'
                    name 'Android Priority Job Queue'
                    version manifestVersionName
                    description 'a Job Queue specifically written for Android to easily schedule jobs (tasks) that run in the background, improving UX and application stability.'
                    url 'https://github.com/yigit/android-priority-jobqueue'

                    parent {
                        groupId 'org.sonatype.oss'
                        artifactId 'oss-parent'
                        version 7
                    }

                    scm {
                        connection 'scm:git:git@github.com:yigit/android-priority-jobqueue.git'
                        developerConnection 'scm:git:git@github.com:yigit/android-priority-jobqueue.git'
                        url 'git@github.com:yigit/android-priority-jobqueue.git'
                    }

                    licenses {
                        license {
                            name 'The MIT License (MIT)'
                            url 'http://opensource.org/licenses/MIT'
                            distribution 'repo'
                        }
                    }

                    developers {
                        developer {
                            id "yigit"
                            name "Yigit Boyar"
                        }
                    }
                }
            }
        }
    }

    signing {
        required { gradle.taskGraph.hasTask("uploadArchives") }
        sign configurations.archives
    }
}
task testLint(type : Exec) {
    workingDir project.projectDir
    // SET ANDROID_LINT_JARS ENV VARIABLE
    commandLine 'lint', '.', '--sources', 'src/test/java', '--disable', 'InlinedApi,AllowBackup,MissingApplicationIcon,LintError,NOTIFY_ON_OBJECT'

}
task jacocoTestReport(type:JacocoReport, dependsOn: "testDebugUnitTest") {
    group = "Reporting"

    description = "Generate Jacoco coverage reports"

    classDirectories = fileTree(
            dir: "$buildDir/intermediates/classes/debug",
            excludes: ['**/R.class',
                       '**/R$*.class',
                       '**/BuildConfig.*',
                       '**/Manifest*.*']
    )

    additionalSourceDirs = files(android.sourceSets.main.getJava().getSrcDirs())
    sourceDirectories = files(android.sourceSets.main.getJava().getSrcDirs())
    executionData = files("$buildDir/jacoco/testDebugUnitTest.exec")

    reports {
        xml.enabled = true
        html.enabled = true
    }
}
tasks.whenTaskAdded { task ->
    if (task instanceof Test) {
        println "adding upload task to ${task.name}"
        task.finalizedBy(tasks.
                create("uploadTestResultsOf${task.name}", UploadToS3Task.class) {
                    fileList = task.outputs.files.asFileTree
                    outputPath = "test-results"
                    filter = { File f ->
                        f.name.endsWith(".html") || f.name.endsWith(".css") ||
                                f.name.endsWith(".js")
                    }
                })

    }
}
